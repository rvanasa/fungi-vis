Bundle { input: "open crate :: examples :: nat ; ret 0", program: Der { ctx: Empty, dir: Synth, term: UseAll(UseAllModule { path: "crate::examples::nat", module: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) } }, Ret(Nat(0))), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: UseAll(UseAllModuleDer { ast: UseAllModule { path: "crate::examples::nat", module: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) } }, der: ModuleDer { ast: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) }, tds: [Bind(ItemDer { doc: Some("r\" Return true if the given natural number is zero, false otherwise.\""), qual: Val, var: "nat_is_zero", der: Der { ctx: Empty, dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_is_zero", Der { ctx: Empty, dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::nat_is_zero"))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Empty, dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), term: HostFn(HostEvalFn("trapdoor::nat_is_zero")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: HostFn(HostEvalFn("trapdoor::nat_is_zero")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Return true if the given natural number is odd, false otherwise.\""), qual: Val, var: "nat_is_odd", der: Der { ctx: Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_is_odd", Der { ctx: Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::nat_is_odd"))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), term: HostFn(HostEvalFn("trapdoor::nat_is_odd")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: HostFn(HostEvalFn("trapdoor::nat_is_odd")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Return the difference of two natural numbers, as a natural number.\""), qual: Val, var: "nat_sub", der: Der { ctx: Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_sub", Der { ctx: Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::nat_sub"))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), term: HostFn(HostEvalFn("trapdoor::nat_sub")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), rule: HostFn(HostEvalFn("trapdoor::nat_sub")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Optional natural numbers\""), qual: Type, var: "OpNat", der: Der { ctx: Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Kind(NoParse("TODO-XXX-bitype.rs"))), rule: Type("OpNat", Sum(Unit, Prim(Nat))), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" If the given number is even, return its successor\""), qual: Val, var: "nat_succ_even", der: Der { ctx: Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_succ_even", Der { ctx: Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(Fix("nat_succ_even", Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), term: Fix("nat_succ_even", Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit)))))), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Fix("nat_succ_even", Der { ctx: Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), term: Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Lam("n", Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit)))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Let("sugar_if_scrutinee", Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: App(Force(Var("nat_is_odd")), Var("n")), clas: Ok(Cons(Lift(Prim(Bool)), WR(Empty, Empty))), rule: App(Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: Force(Var("nat_is_odd")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: Force(Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: Var("nat_is_odd"), clas: Ok(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), rule: Var("nat_is_odd"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: IfThenElse(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("sugar_if_scrutinee"), clas: Ok(Prim(Bool)), rule: Var("sugar_if_scrutinee"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Let("m", Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: PrimApp(NatPlus(Var("n"), Nat(1))), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: PrimApp(NatPlus(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Nat(1), clas: Ok(Prim(Nat)), rule: Nat(1), vis: DerVis { tmfam: "Val", local_err: false } })), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Inj2(Var("m"))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj2(Var("m")), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj2(Der { ctx: Var(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("m"), clas: Ok(Prim(Nat)), rule: Var("m"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Inj1(Unit)), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj1(Unit), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj1(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Unit), term: Unit, clas: Ok(Unit), rule: Unit, vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } })], ctx_out: Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))) } }, Der { ctx: Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: Ret(Nat(0)), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: Nat(0), clas: Ok(Prim(Nat)), rule: Nat(0), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, traces: [] }