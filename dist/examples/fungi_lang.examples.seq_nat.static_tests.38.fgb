Bundle { input: "open crate :: examples :: seq_nat ; ret 0", program: Der { ctx: Empty, dir: Synth, term: UseAll(UseAllModule { path: "crate::examples::seq_nat", module: Module { path: "fungi_lang::examples::seq_nat", body: "type Lev = (Nat) ; # [doc = r\" Level trees of natural numbers\"] type Seq =\n(rec seq . foralli (X, Y) : NmSet .\n (+ Unit + (x Nm [X] x Nat)\n  (exists (X1, X2, X3) : NmSet | ((X1 % X2 % X3) = X : NmSet) . x Nm [X1] x\n   Lev x Ref [Y] (seq [X2] [Y]) x Ref [Y] (seq [X3] [Y])))) ; #\n[doc = r\" References to sequences of natural numbers\"] type RefSeq =\n(foralli (X, Y) : NmSet . Ref [Y] (Seq [X] [Y])) ;", decls: Type("Lev", Ident("Nat"), Doc("r\" Level trees of natural numbers\"", Type("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Ident("Nat")), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(Ident("Lev"), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Doc("r\" References to sequences of natural numbers\"", Type("RefSeq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(Ident("Seq"), Var("X")), Var("Y"))))), End))))) } }, Ret(Nat(0))), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: UseAll(UseAllModuleDer { ast: UseAllModule { path: "crate::examples::seq_nat", module: Module { path: "fungi_lang::examples::seq_nat", body: "type Lev = (Nat) ; # [doc = r\" Level trees of natural numbers\"] type Seq =\n(rec seq . foralli (X, Y) : NmSet .\n (+ Unit + (x Nm [X] x Nat)\n  (exists (X1, X2, X3) : NmSet | ((X1 % X2 % X3) = X : NmSet) . x Nm [X1] x\n   Lev x Ref [Y] (seq [X2] [Y]) x Ref [Y] (seq [X3] [Y])))) ; #\n[doc = r\" References to sequences of natural numbers\"] type RefSeq =\n(foralli (X, Y) : NmSet . Ref [Y] (Seq [X] [Y])) ;", decls: Type("Lev", Ident("Nat"), Doc("r\" Level trees of natural numbers\"", Type("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Ident("Nat")), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(Ident("Lev"), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Doc("r\" References to sequences of natural numbers\"", Type("RefSeq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(Ident("Seq"), Var("X")), Var("Y"))))), End))))) } }, der: ModuleDer { ast: Module { path: "fungi_lang::examples::seq_nat", body: "type Lev = (Nat) ; # [doc = r\" Level trees of natural numbers\"] type Seq =\n(rec seq . foralli (X, Y) : NmSet .\n (+ Unit + (x Nm [X] x Nat)\n  (exists (X1, X2, X3) : NmSet | ((X1 % X2 % X3) = X : NmSet) . x Nm [X1] x\n   Lev x Ref [Y] (seq [X2] [Y]) x Ref [Y] (seq [X3] [Y])))) ; #\n[doc = r\" References to sequences of natural numbers\"] type RefSeq =\n(foralli (X, Y) : NmSet . Ref [Y] (Seq [X] [Y])) ;", decls: Type("Lev", Ident("Nat"), Doc("r\" Level trees of natural numbers\"", Type("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Ident("Nat")), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(Ident("Lev"), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Doc("r\" References to sequences of natural numbers\"", Type("RefSeq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(Ident("Seq"), Var("X")), Var("Y"))))), End))))) }, tds: [Bind(ItemDer { doc: None, qual: Type, var: "Lev", der: Der { ctx: Empty, dir: Synth, term: (), clas: Ok(Kind(NoParse("TODO-XXX-bitype.rs"))), rule: Type("Lev", Prim(Nat)), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Level trees of natural numbers\""), qual: Type, var: "Seq", der: Der { ctx: Def(Empty, "Lev", Type(Prim(Nat))), dir: Synth, term: (), clas: Ok(Kind(NoParse("TODO-XXX-bitype.rs"))), rule: Type("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" References to sequences of natural numbers\""), qual: Type, var: "RefSeq", der: Der { ctx: Def(Def(Empty, "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), dir: Synth, term: (), clas: Ok(Kind(NoParse("TODO-XXX-bitype.rs"))), rule: Type("RefSeq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y")))))), vis: DerVis { tmfam: "Module", local_err: false } } })], ctx_out: Def(Def(Def(Empty, "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))) } }, Der { ctx: Def(Def(Def(Empty, "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), dir: Synth, term: Ret(Nat(0)), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: Ret(Der { ctx: Def(Def(Def(Empty, "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), dir: Synth, term: Nat(0), clas: Ok(Prim(Nat)), rule: Nat(0), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, traces: [] }