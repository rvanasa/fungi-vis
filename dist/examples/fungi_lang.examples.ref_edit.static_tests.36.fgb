Bundle { input: "open crate :: examples :: ref_edit ; ret 0", program: Der { ctx: Empty, dir: Synth, term: UseAll(UseAllModule { path: "crate::examples::ref_edit", module: Module { path: "fungi_lang::examples::ref_edit", body: "# [doc = r\" Imperatively update a reference cell\'s content\"] fn ref_update :\n(Thk [0] foralli X : NmSet . forall A . 0 Ref [X] A -> 0 A -> { X ; 0 } F\n Unit) = { unsafe (2) trapdoor :: ref_update }", decls: Doc("r\" Imperatively update a reference cell\'s content\"", Fn("ref_update", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(TypeApp(IdxApp(TypeApp(TypeApp(TypeApp(Ident("A"), NoParse(".")), NoParse("0")), Ident("Ref")), Var("X")), Ident("A")), Cons(Arrow(Ident("A"), Cons(Lift(Unit), WR(Var("X"), Empty))), WR(Empty, Empty))), NoParse("forall")))), HostFn(HostEvalFn("trapdoor::ref_update")), End)) } }, Ret(Nat(0))), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: UseAll(UseAllModuleDer { ast: UseAllModule { path: "crate::examples::ref_edit", module: Module { path: "fungi_lang::examples::ref_edit", body: "# [doc = r\" Imperatively update a reference cell\'s content\"] fn ref_update :\n(Thk [0] foralli X : NmSet . forall A . 0 Ref [X] A -> 0 A -> { X ; 0 } F\n Unit) = { unsafe (2) trapdoor :: ref_update }", decls: Doc("r\" Imperatively update a reference cell\'s content\"", Fn("ref_update", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(TypeApp(IdxApp(TypeApp(TypeApp(TypeApp(Ident("A"), NoParse(".")), NoParse("0")), Ident("Ref")), Var("X")), Ident("A")), Cons(Arrow(Ident("A"), Cons(Lift(Unit), WR(Var("X"), Empty))), WR(Empty, Empty))), NoParse("forall")))), HostFn(HostEvalFn("trapdoor::ref_update")), End)) } }, der: ModuleDer { ast: Module { path: "fungi_lang::examples::ref_edit", body: "# [doc = r\" Imperatively update a reference cell\'s content\"] fn ref_update :\n(Thk [0] foralli X : NmSet . forall A . 0 Ref [X] A -> 0 A -> { X ; 0 } F\n Unit) = { unsafe (2) trapdoor :: ref_update }", decls: Doc("r\" Imperatively update a reference cell\'s content\"", Fn("ref_update", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(TypeApp(IdxApp(TypeApp(TypeApp(TypeApp(Ident("A"), NoParse(".")), NoParse("0")), Ident("Ref")), Var("X")), Ident("A")), Cons(Arrow(Ident("A"), Cons(Lift(Unit), WR(Var("X"), Empty))), WR(Empty, Empty))), NoParse("forall")))), HostFn(HostEvalFn("trapdoor::ref_update")), End)) }, tds: [Bind(ItemDer { doc: Some("r\" Imperatively update a reference cell\'s content\""), qual: Val, var: "ref_update", der: Der { ctx: Empty, dir: Synth, term: (), clas: Ok(Type(Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(TypeApp(IdxApp(TypeApp(TypeApp(TypeApp(Ident("A"), NoParse(".")), NoParse("0")), Ident("Ref")), Var("X")), Ident("A")), Cons(Arrow(Ident("A"), Cons(Lift(Unit), WR(Var("X"), Empty))), WR(Empty, Empty))), NoParse("forall")))))), rule: Fn("ref_update", Der { ctx: Empty, dir: Check(Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(TypeApp(IdxApp(TypeApp(TypeApp(TypeApp(Ident("A"), NoParse(".")), NoParse("0")), Ident("Ref")), Var("X")), Ident("A")), Cons(Arrow(Ident("A"), Cons(Lift(Unit), WR(Var("X"), Empty))), WR(Empty, Empty))), NoParse("forall"))))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::ref_update"))), clas: Ok(Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(TypeApp(IdxApp(TypeApp(TypeApp(TypeApp(Ident("A"), NoParse(".")), NoParse("0")), Ident("Ref")), Var("X")), Ident("A")), Cons(Arrow(Ident("A"), Cons(Lift(Unit), WR(Var("X"), Empty))), WR(Empty, Empty))), NoParse("forall"))))), rule: ThunkAnon(Der { ctx: Empty, dir: Check(ForallIdx("X", NmSet, Tt, Cons(Arrow(TypeApp(IdxApp(TypeApp(TypeApp(TypeApp(IdentUndef("A"), NoParse(".")), NoParse("0")), IdentUndef("Ref")), Var("X")), IdentUndef("A")), Cons(Arrow(IdentUndef("A"), Cons(Lift(Unit), WR(Var("X"), Empty))), WR(Empty, Empty))), NoParse("forall")))), term: HostFn(HostEvalFn("trapdoor::ref_update")), clas: Ok(ForallIdx("X", NmSet, Tt, Cons(Arrow(TypeApp(IdxApp(TypeApp(TypeApp(TypeApp(IdentUndef("A"), NoParse(".")), NoParse("0")), IdentUndef("Ref")), Var("X")), IdentUndef("A")), Cons(Arrow(IdentUndef("A"), Cons(Lift(Unit), WR(Var("X"), Empty))), WR(Empty, Empty))), NoParse("forall")))), rule: HostFn(HostEvalFn("trapdoor::ref_update")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } })], ctx_out: Var(Empty, "ref_update", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(TypeApp(IdxApp(TypeApp(TypeApp(TypeApp(IdentUndef("A"), NoParse(".")), NoParse("0")), IdentUndef("Ref")), Var("X")), IdentUndef("A")), Cons(Arrow(IdentUndef("A"), Cons(Lift(Unit), WR(Var("X"), Empty))), WR(Empty, Empty))), NoParse("forall"))))) } }, Der { ctx: Var(Empty, "ref_update", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(TypeApp(IdxApp(TypeApp(TypeApp(TypeApp(IdentUndef("A"), NoParse(".")), NoParse("0")), IdentUndef("Ref")), Var("X")), IdentUndef("A")), Cons(Arrow(IdentUndef("A"), Cons(Lift(Unit), WR(Var("X"), Empty))), WR(Empty, Empty))), NoParse("forall"))))), dir: Synth, term: Ret(Nat(0)), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Empty, "ref_update", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(TypeApp(IdxApp(TypeApp(TypeApp(TypeApp(IdentUndef("A"), NoParse(".")), NoParse("0")), IdentUndef("Ref")), Var("X")), IdentUndef("A")), Cons(Arrow(IdentUndef("A"), Cons(Lift(Unit), WR(Var("X"), Empty))), WR(Empty, Empty))), NoParse("forall"))))), dir: Synth, term: Nat(0), clas: Ok(Prim(Nat)), rule: Nat(0), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, traces: [] }