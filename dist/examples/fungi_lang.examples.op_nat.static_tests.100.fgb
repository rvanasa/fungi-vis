Bundle { input: "open crate :: examples :: op_nat ; ret 0", program: Der { ctx: Empty, dir: Synth, term: UseAll(UseAllModule { path: "crate::examples::op_nat", module: Module { path: "fungi_lang::examples::op_nat", body: "open crate :: examples :: nat ; # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; # [doc = r\" Optional pairs of natural numbers\"] type\nOp2Nat = (+ Unit + (x Nat x Nat)) ; fn opnat_split :\n(Thk [0] 0 Op2Nat -> 0 F (x OpNat x OpNat)) =\n{\n    # xyo . match (xyo)\n    {\n        _u => { ret (inj1 (), inj1 ()) } xy =>\n        { let (x, y) = { ret xy } ret (inj2 x, inj2 y) }\n    }\n} fn opnat_pair : (Thk [0] 0 (x OpNat x OpNat) -> 0 F (Op2Nat)) =\n{\n    # xoyo . let (xo, yo) = { ret xoyo } match (xo)\n    {\n        _u => { ret inj1 () } x =>\n        { match (yo) { _u => { ret inj1 () } y => { ret inj2 (x, y) } } }\n    }\n} fn opnat_filter_nat :\n(Thk [0] 0 OpNat -> 0 (Thk [0] 0 Nat -> 0 F Bool) -> 0 F OpNat) =\n{\n    # opnat . # pred . match opnat\n    {\n        _u => { ret inj1 () } n =>\n        { if { { force pred } n } { ret inj2 n } else { ret inj1 () } }\n    }\n} fn opnat_max : (Thk [0] 0 OpNat -> 0 OpNat -> 0 F OpNat) =\n{\n    # xo . # yo . match (xo)\n    {\n        _u => { ret yo } x =>\n        {\n            match (yo)\n            {\n                _u => { ret yo } y =>\n                { if { x < y } { ret yo } else { ret xo } }\n            }\n        }\n    }\n} # [doc = r\" If the given number is even, return its successor\"] fn\nnat_succ_even : (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: UseAll(UseAllModule { path: "crate::examples::nat", module: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) } }, Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" Optional pairs of natural numbers\"", Type("Op2Nat", Sum(Unit, Prod(Ident("Nat"), Ident("Nat"))), Fn("opnat_split", Thk(Empty, Cons(Arrow(Ident("Op2Nat"), Cons(Lift(Prod(Ident("OpNat"), Ident("OpNat"))), WR(Empty, Empty))), WR(Empty, Empty))), Lam("xyo", Case(Var("xyo"), "_u", Ret(Pair(Inj1(Unit), Inj1(Unit))), "xy", Let("let_split_sugar", Ret(Var("xy")), Split(Var("let_split_sugar"), "x", "y", Ret(Pair(Inj2(Var("x")), Inj2(Var("y")))))))), Fn("opnat_pair", Thk(Empty, Cons(Arrow(Prod(Ident("OpNat"), Ident("OpNat")), Cons(Lift(Ident("Op2Nat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("xoyo", Let("let_split_sugar", Ret(Var("xoyo")), Split(Var("let_split_sugar"), "xo", "yo", Case(Var("xo"), "_u", Ret(Inj1(Unit)), "x", Case(Var("yo"), "_u", Ret(Inj1(Unit)), "y", Ret(Inj2(Pair(Var("x"), Var("y"))))))))), Fn("opnat_filter_nat", Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), Lam("opnat", Lam("pred", Case(Var("opnat"), "_u", Ret(Inj1(Unit)), "n", Let("sugar_if_scrutinee", App(Force(Var("pred")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ret(Inj2(Var("n"))), Ret(Inj1(Unit))))))), Fn("opnat_max", Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Ident("OpNat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), Lam("xo", Lam("yo", Case(Var("xo"), "_u", Ret(Var("yo")), "x", Case(Var("yo"), "_u", Ret(Var("yo")), "y", Let("sugar_if_scrutinee", PrimApp(NatLt(Var("x"), Var("y"))), IfThenElse(Var("sugar_if_scrutinee"), Ret(Var("yo")), Ret(Var("xo")))))))), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End))))))))))) } }, Ret(Nat(0))), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: UseAll(UseAllModuleDer { ast: UseAllModule { path: "crate::examples::op_nat", module: Module { path: "fungi_lang::examples::op_nat", body: "open crate :: examples :: nat ; # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; # [doc = r\" Optional pairs of natural numbers\"] type\nOp2Nat = (+ Unit + (x Nat x Nat)) ; fn opnat_split :\n(Thk [0] 0 Op2Nat -> 0 F (x OpNat x OpNat)) =\n{\n    # xyo . match (xyo)\n    {\n        _u => { ret (inj1 (), inj1 ()) } xy =>\n        { let (x, y) = { ret xy } ret (inj2 x, inj2 y) }\n    }\n} fn opnat_pair : (Thk [0] 0 (x OpNat x OpNat) -> 0 F (Op2Nat)) =\n{\n    # xoyo . let (xo, yo) = { ret xoyo } match (xo)\n    {\n        _u => { ret inj1 () } x =>\n        { match (yo) { _u => { ret inj1 () } y => { ret inj2 (x, y) } } }\n    }\n} fn opnat_filter_nat :\n(Thk [0] 0 OpNat -> 0 (Thk [0] 0 Nat -> 0 F Bool) -> 0 F OpNat) =\n{\n    # opnat . # pred . match opnat\n    {\n        _u => { ret inj1 () } n =>\n        { if { { force pred } n } { ret inj2 n } else { ret inj1 () } }\n    }\n} fn opnat_max : (Thk [0] 0 OpNat -> 0 OpNat -> 0 F OpNat) =\n{\n    # xo . # yo . match (xo)\n    {\n        _u => { ret yo } x =>\n        {\n            match (yo)\n            {\n                _u => { ret yo } y =>\n                { if { x < y } { ret yo } else { ret xo } }\n            }\n        }\n    }\n} # [doc = r\" If the given number is even, return its successor\"] fn\nnat_succ_even : (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: UseAll(UseAllModule { path: "crate::examples::nat", module: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) } }, Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" Optional pairs of natural numbers\"", Type("Op2Nat", Sum(Unit, Prod(Ident("Nat"), Ident("Nat"))), Fn("opnat_split", Thk(Empty, Cons(Arrow(Ident("Op2Nat"), Cons(Lift(Prod(Ident("OpNat"), Ident("OpNat"))), WR(Empty, Empty))), WR(Empty, Empty))), Lam("xyo", Case(Var("xyo"), "_u", Ret(Pair(Inj1(Unit), Inj1(Unit))), "xy", Let("let_split_sugar", Ret(Var("xy")), Split(Var("let_split_sugar"), "x", "y", Ret(Pair(Inj2(Var("x")), Inj2(Var("y")))))))), Fn("opnat_pair", Thk(Empty, Cons(Arrow(Prod(Ident("OpNat"), Ident("OpNat")), Cons(Lift(Ident("Op2Nat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("xoyo", Let("let_split_sugar", Ret(Var("xoyo")), Split(Var("let_split_sugar"), "xo", "yo", Case(Var("xo"), "_u", Ret(Inj1(Unit)), "x", Case(Var("yo"), "_u", Ret(Inj1(Unit)), "y", Ret(Inj2(Pair(Var("x"), Var("y"))))))))), Fn("opnat_filter_nat", Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), Lam("opnat", Lam("pred", Case(Var("opnat"), "_u", Ret(Inj1(Unit)), "n", Let("sugar_if_scrutinee", App(Force(Var("pred")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ret(Inj2(Var("n"))), Ret(Inj1(Unit))))))), Fn("opnat_max", Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Ident("OpNat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), Lam("xo", Lam("yo", Case(Var("xo"), "_u", Ret(Var("yo")), "x", Case(Var("yo"), "_u", Ret(Var("yo")), "y", Let("sugar_if_scrutinee", PrimApp(NatLt(Var("x"), Var("y"))), IfThenElse(Var("sugar_if_scrutinee"), Ret(Var("yo")), Ret(Var("xo")))))))), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End))))))))))) } }, der: ModuleDer { ast: Module { path: "fungi_lang::examples::op_nat", body: "open crate :: examples :: nat ; # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; # [doc = r\" Optional pairs of natural numbers\"] type\nOp2Nat = (+ Unit + (x Nat x Nat)) ; fn opnat_split :\n(Thk [0] 0 Op2Nat -> 0 F (x OpNat x OpNat)) =\n{\n    # xyo . match (xyo)\n    {\n        _u => { ret (inj1 (), inj1 ()) } xy =>\n        { let (x, y) = { ret xy } ret (inj2 x, inj2 y) }\n    }\n} fn opnat_pair : (Thk [0] 0 (x OpNat x OpNat) -> 0 F (Op2Nat)) =\n{\n    # xoyo . let (xo, yo) = { ret xoyo } match (xo)\n    {\n        _u => { ret inj1 () } x =>\n        { match (yo) { _u => { ret inj1 () } y => { ret inj2 (x, y) } } }\n    }\n} fn opnat_filter_nat :\n(Thk [0] 0 OpNat -> 0 (Thk [0] 0 Nat -> 0 F Bool) -> 0 F OpNat) =\n{\n    # opnat . # pred . match opnat\n    {\n        _u => { ret inj1 () } n =>\n        { if { { force pred } n } { ret inj2 n } else { ret inj1 () } }\n    }\n} fn opnat_max : (Thk [0] 0 OpNat -> 0 OpNat -> 0 F OpNat) =\n{\n    # xo . # yo . match (xo)\n    {\n        _u => { ret yo } x =>\n        {\n            match (yo)\n            {\n                _u => { ret yo } y =>\n                { if { x < y } { ret yo } else { ret xo } }\n            }\n        }\n    }\n} # [doc = r\" If the given number is even, return its successor\"] fn\nnat_succ_even : (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: UseAll(UseAllModule { path: "crate::examples::nat", module: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) } }, Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" Optional pairs of natural numbers\"", Type("Op2Nat", Sum(Unit, Prod(Ident("Nat"), Ident("Nat"))), Fn("opnat_split", Thk(Empty, Cons(Arrow(Ident("Op2Nat"), Cons(Lift(Prod(Ident("OpNat"), Ident("OpNat"))), WR(Empty, Empty))), WR(Empty, Empty))), Lam("xyo", Case(Var("xyo"), "_u", Ret(Pair(Inj1(Unit), Inj1(Unit))), "xy", Let("let_split_sugar", Ret(Var("xy")), Split(Var("let_split_sugar"), "x", "y", Ret(Pair(Inj2(Var("x")), Inj2(Var("y")))))))), Fn("opnat_pair", Thk(Empty, Cons(Arrow(Prod(Ident("OpNat"), Ident("OpNat")), Cons(Lift(Ident("Op2Nat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("xoyo", Let("let_split_sugar", Ret(Var("xoyo")), Split(Var("let_split_sugar"), "xo", "yo", Case(Var("xo"), "_u", Ret(Inj1(Unit)), "x", Case(Var("yo"), "_u", Ret(Inj1(Unit)), "y", Ret(Inj2(Pair(Var("x"), Var("y"))))))))), Fn("opnat_filter_nat", Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), Lam("opnat", Lam("pred", Case(Var("opnat"), "_u", Ret(Inj1(Unit)), "n", Let("sugar_if_scrutinee", App(Force(Var("pred")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ret(Inj2(Var("n"))), Ret(Inj1(Unit))))))), Fn("opnat_max", Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Ident("OpNat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), Lam("xo", Lam("yo", Case(Var("xo"), "_u", Ret(Var("yo")), "x", Case(Var("yo"), "_u", Ret(Var("yo")), "y", Let("sugar_if_scrutinee", PrimApp(NatLt(Var("x"), Var("y"))), IfThenElse(Var("sugar_if_scrutinee"), Ret(Var("yo")), Ret(Var("xo")))))))), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End))))))))))) }, tds: [UseAll(UseAllModuleDer { ast: UseAllModule { path: "crate::examples::nat", module: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) } }, der: ModuleDer { ast: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) }, tds: [Bind(ItemDer { doc: Some("r\" Return true if the given natural number is zero, false otherwise.\""), qual: Val, var: "nat_is_zero", der: Der { ctx: Empty, dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_is_zero", Der { ctx: Empty, dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::nat_is_zero"))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Empty, dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), term: HostFn(HostEvalFn("trapdoor::nat_is_zero")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: HostFn(HostEvalFn("trapdoor::nat_is_zero")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Return true if the given natural number is odd, false otherwise.\""), qual: Val, var: "nat_is_odd", der: Der { ctx: Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_is_odd", Der { ctx: Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::nat_is_odd"))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), term: HostFn(HostEvalFn("trapdoor::nat_is_odd")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: HostFn(HostEvalFn("trapdoor::nat_is_odd")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Return the difference of two natural numbers, as a natural number.\""), qual: Val, var: "nat_sub", der: Der { ctx: Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_sub", Der { ctx: Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::nat_sub"))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), term: HostFn(HostEvalFn("trapdoor::nat_sub")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), rule: HostFn(HostEvalFn("trapdoor::nat_sub")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Optional natural numbers\""), qual: Type, var: "OpNat", der: Der { ctx: Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Kind(NoParse("TODO-XXX-bitype.rs"))), rule: Type("OpNat", Sum(Unit, Prim(Nat))), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" If the given number is even, return its successor\""), qual: Val, var: "nat_succ_even", der: Der { ctx: Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_succ_even", Der { ctx: Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(Fix("nat_succ_even", Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), term: Fix("nat_succ_even", Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit)))))), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Fix("nat_succ_even", Der { ctx: Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), term: Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Lam("n", Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit)))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Let("sugar_if_scrutinee", Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: App(Force(Var("nat_is_odd")), Var("n")), clas: Ok(Cons(Lift(Prim(Bool)), WR(Empty, Empty))), rule: App(Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: Force(Var("nat_is_odd")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: Force(Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: Var("nat_is_odd"), clas: Ok(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), rule: Var("nat_is_odd"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: IfThenElse(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("sugar_if_scrutinee"), clas: Ok(Prim(Bool)), rule: Var("sugar_if_scrutinee"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Let("m", Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: PrimApp(NatPlus(Var("n"), Nat(1))), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: PrimApp(NatPlus(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Nat(1), clas: Ok(Prim(Nat)), rule: Nat(1), vis: DerVis { tmfam: "Val", local_err: false } })), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Inj2(Var("m"))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj2(Var("m")), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj2(Der { ctx: Var(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("m"), clas: Ok(Prim(Nat)), rule: Var("m"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Inj1(Unit)), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj1(Unit), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj1(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Unit), term: Unit, clas: Ok(Unit), rule: Unit, vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } })], ctx_out: Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))) } }), Bind(ItemDer { doc: Some("r\" Optional natural numbers\""), qual: Type, var: "OpNat", der: Der { ctx: Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Kind(NoParse("TODO-XXX-bitype.rs"))), rule: Type("OpNat", Sum(Unit, Prim(Nat))), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Optional pairs of natural numbers\""), qual: Type, var: "Op2Nat", der: Der { ctx: Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), dir: Synth, term: (), clas: Ok(Kind(NoParse("TODO-XXX-bitype.rs"))), rule: Type("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: None, qual: Val, var: "opnat_split", der: Der { ctx: Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Op2Nat"), Cons(Lift(Prod(Ident("OpNat"), Ident("OpNat"))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("opnat_split", Der { ctx: Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), dir: Check(Thk(Empty, Cons(Arrow(Ident("Op2Nat"), Cons(Lift(Prod(Ident("OpNat"), Ident("OpNat"))), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(Fix("opnat_split", Lam("xyo", Case(Var("xyo"), "_u", Ret(Pair(Inj1(Unit), Inj1(Unit))), "xy", Let("let_split_sugar", Ret(Var("xy")), Split(Var("let_split_sugar"), "x", "y", Ret(Pair(Inj2(Var("x")), Inj2(Var("y")))))))))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Op2Nat"), Cons(Lift(Prod(Ident("OpNat"), Ident("OpNat"))), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), dir: Check(Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty))), term: Fix("opnat_split", Lam("xyo", Case(Var("xyo"), "_u", Ret(Pair(Inj1(Unit), Inj1(Unit))), "xy", Let("let_split_sugar", Ret(Var("xy")), Split(Var("let_split_sugar"), "x", "y", Ret(Pair(Inj2(Var("x")), Inj2(Var("y"))))))))), clas: Ok(Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Fix("opnat_split", Der { ctx: Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty))), term: Lam("xyo", Case(Var("xyo"), "_u", Ret(Pair(Inj1(Unit), Inj1(Unit))), "xy", Let("let_split_sugar", Ret(Var("xy")), Split(Var("let_split_sugar"), "x", "y", Ret(Pair(Inj2(Var("x")), Inj2(Var("y")))))))), clas: Ok(Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Lam("xyo", Der { ctx: Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), dir: Check(Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), term: Case(Var("xyo"), "_u", Ret(Pair(Inj1(Unit), Inj1(Unit))), "xy", Let("let_split_sugar", Ret(Var("xy")), Split(Var("let_split_sugar"), "x", "y", Ret(Pair(Inj2(Var("x")), Inj2(Var("y"))))))), clas: Ok(Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), rule: Case(Der { ctx: Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), dir: Synth, term: Var("xyo"), clas: Ok(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), rule: Var("xyo"), vis: DerVis { tmfam: "Val", local_err: false } }, "_u", Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "_u", Unit), dir: Check(Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), term: Ret(Pair(Inj1(Unit), Inj1(Unit))), clas: Ok(Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "_u", Unit), dir: Check(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), term: Pair(Inj1(Unit), Inj1(Unit)), clas: Ok(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), rule: Pair(Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "_u", Unit), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj1(Unit), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj1(Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "_u", Unit), dir: Check(Unit), term: Unit, clas: Ok(Unit), rule: Unit, vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "_u", Unit), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj1(Unit), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj1(Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "_u", Unit), dir: Check(Unit), term: Unit, clas: Ok(Unit), rule: Unit, vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, "xy", Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "xy", Prod(Prim(Nat), Prim(Nat))), dir: Check(Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), term: Let("let_split_sugar", Ret(Var("xy")), Split(Var("let_split_sugar"), "x", "y", Ret(Pair(Inj2(Var("x")), Inj2(Var("y")))))), clas: Ok(Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), rule: Let("let_split_sugar", Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "xy", Prod(Prim(Nat), Prim(Nat))), dir: Synth, term: Ret(Var("xy")), clas: Ok(Cons(Lift(Prod(Prim(Nat), Prim(Nat))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "xy", Prod(Prim(Nat), Prim(Nat))), dir: Synth, term: Var("xy"), clas: Ok(Prod(Prim(Nat), Prim(Nat))), rule: Var("xy"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "xy", Prod(Prim(Nat), Prim(Nat))), "let_split_sugar", Prod(Prim(Nat), Prim(Nat))), dir: Check(Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), term: Split(Var("let_split_sugar"), "x", "y", Ret(Pair(Inj2(Var("x")), Inj2(Var("y"))))), clas: Ok(Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), rule: Split(Der { ctx: Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "xy", Prod(Prim(Nat), Prim(Nat))), "let_split_sugar", Prod(Prim(Nat), Prim(Nat))), dir: Synth, term: Var("let_split_sugar"), clas: Ok(Prod(Prim(Nat), Prim(Nat))), rule: Var("let_split_sugar"), vis: DerVis { tmfam: "Val", local_err: false } }, "x", "y", Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "xy", Prod(Prim(Nat), Prim(Nat))), "let_split_sugar", Prod(Prim(Nat), Prim(Nat))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), term: Ret(Pair(Inj2(Var("x")), Inj2(Var("y")))), clas: Ok(Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "xy", Prod(Prim(Nat), Prim(Nat))), "let_split_sugar", Prod(Prim(Nat), Prim(Nat))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), term: Pair(Inj2(Var("x")), Inj2(Var("y"))), clas: Ok(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), rule: Pair(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "xy", Prod(Prim(Nat), Prim(Nat))), "let_split_sugar", Prod(Prim(Nat), Prim(Nat))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj2(Var("x")), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj2(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "xy", Prod(Prim(Nat), Prim(Nat))), "let_split_sugar", Prod(Prim(Nat), Prim(Nat))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("x"), clas: Ok(Prim(Nat)), rule: Var("x"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "xy", Prod(Prim(Nat), Prim(Nat))), "let_split_sugar", Prod(Prim(Nat), Prim(Nat))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj2(Var("y")), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj2(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xyo", IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "xy", Prod(Prim(Nat), Prim(Nat))), "let_split_sugar", Prod(Prim(Nat), Prim(Nat))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("y"), clas: Ok(Prim(Nat)), rule: Var("y"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: None, qual: Val, var: "opnat_pair", der: Der { ctx: Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Prod(Ident("OpNat"), Ident("OpNat")), Cons(Lift(Ident("Op2Nat")), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("opnat_pair", Der { ctx: Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Thk(Empty, Cons(Arrow(Prod(Ident("OpNat"), Ident("OpNat")), Cons(Lift(Ident("Op2Nat")), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(Fix("opnat_pair", Lam("xoyo", Let("let_split_sugar", Ret(Var("xoyo")), Split(Var("let_split_sugar"), "xo", "yo", Case(Var("xo"), "_u", Ret(Inj1(Unit)), "x", Case(Var("yo"), "_u", Ret(Inj1(Unit)), "y", Ret(Inj2(Pair(Var("x"), Var("y"))))))))))), clas: Ok(Thk(Empty, Cons(Arrow(Prod(Ident("OpNat"), Ident("OpNat")), Cons(Lift(Ident("Op2Nat")), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty))), term: Fix("opnat_pair", Lam("xoyo", Let("let_split_sugar", Ret(Var("xoyo")), Split(Var("let_split_sugar"), "xo", "yo", Case(Var("xo"), "_u", Ret(Inj1(Unit)), "x", Case(Var("yo"), "_u", Ret(Inj1(Unit)), "y", Ret(Inj2(Pair(Var("x"), Var("y")))))))))), clas: Ok(Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Fix("opnat_pair", Der { ctx: Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty))), term: Lam("xoyo", Let("let_split_sugar", Ret(Var("xoyo")), Split(Var("let_split_sugar"), "xo", "yo", Case(Var("xo"), "_u", Ret(Inj1(Unit)), "x", Case(Var("yo"), "_u", Ret(Inj1(Unit)), "y", Ret(Inj2(Pair(Var("x"), Var("y"))))))))), clas: Ok(Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Lam("xoyo", Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), dir: Check(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), term: Let("let_split_sugar", Ret(Var("xoyo")), Split(Var("let_split_sugar"), "xo", "yo", Case(Var("xo"), "_u", Ret(Inj1(Unit)), "x", Case(Var("yo"), "_u", Ret(Inj1(Unit)), "y", Ret(Inj2(Pair(Var("x"), Var("y")))))))), clas: Ok(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), rule: Let("let_split_sugar", Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), dir: Synth, term: Ret(Var("xoyo")), clas: Ok(Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), dir: Synth, term: Var("xoyo"), clas: Ok(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), rule: Var("xoyo"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), dir: Check(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), term: Split(Var("let_split_sugar"), "xo", "yo", Case(Var("xo"), "_u", Ret(Inj1(Unit)), "x", Case(Var("yo"), "_u", Ret(Inj1(Unit)), "y", Ret(Inj2(Pair(Var("x"), Var("y"))))))), clas: Ok(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), rule: Split(Der { ctx: Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), dir: Synth, term: Var("let_split_sugar"), clas: Ok(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), rule: Var("let_split_sugar"), vis: DerVis { tmfam: "Val", local_err: false } }, "xo", "yo", Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), dir: Check(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), term: Case(Var("xo"), "_u", Ret(Inj1(Unit)), "x", Case(Var("yo"), "_u", Ret(Inj1(Unit)), "y", Ret(Inj2(Pair(Var("x"), Var("y")))))), clas: Ok(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), rule: Case(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), dir: Synth, term: Var("xo"), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Var("xo"), vis: DerVis { tmfam: "Val", local_err: false } }, "_u", Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "_u", Unit), dir: Check(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), term: Ret(Inj1(Unit)), clas: Ok(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "_u", Unit), dir: Check(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), term: Inj1(Unit), clas: Ok(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), rule: Inj1(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "_u", Unit), dir: Check(Unit), term: Unit, clas: Ok(Unit), rule: Unit, vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, "x", Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), term: Case(Var("yo"), "_u", Ret(Inj1(Unit)), "y", Ret(Inj2(Pair(Var("x"), Var("y"))))), clas: Ok(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), rule: Case(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), dir: Synth, term: Var("yo"), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Var("yo"), vis: DerVis { tmfam: "Val", local_err: false } }, "_u", Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "_u", Unit), dir: Check(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), term: Ret(Inj1(Unit)), clas: Ok(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "_u", Unit), dir: Check(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), term: Inj1(Unit), clas: Ok(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), rule: Inj1(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "_u", Unit), dir: Check(Unit), term: Unit, clas: Ok(Unit), rule: Unit, vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, "y", Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), term: Ret(Inj2(Pair(Var("x"), Var("y")))), clas: Ok(Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), term: Inj2(Pair(Var("x"), Var("y"))), clas: Ok(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), rule: Inj2(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(Prod(Prim(Nat), Prim(Nat))), term: Pair(Var("x"), Var("y")), clas: Ok(Prod(Prim(Nat), Prim(Nat))), rule: Pair(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("x"), clas: Ok(Prim(Nat)), rule: Var("x"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "xoyo", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "let_split_sugar", Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("y"), clas: Ok(Prim(Nat)), rule: Var("y"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: None, qual: Val, var: "opnat_filter_nat", der: Der { ctx: Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("opnat_filter_nat", Der { ctx: Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(Fix("opnat_filter_nat", Lam("opnat", Lam("pred", Case(Var("opnat"), "_u", Ret(Inj1(Unit)), "n", Let("sugar_if_scrutinee", App(Force(Var("pred")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ret(Inj2(Var("n"))), Ret(Inj1(Unit))))))))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), term: Fix("opnat_filter_nat", Lam("opnat", Lam("pred", Case(Var("opnat"), "_u", Ret(Inj1(Unit)), "n", Let("sugar_if_scrutinee", App(Force(Var("pred")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ret(Inj2(Var("n"))), Ret(Inj1(Unit)))))))), clas: Ok(Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Fix("opnat_filter_nat", Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), term: Lam("opnat", Lam("pred", Case(Var("opnat"), "_u", Ret(Inj1(Unit)), "n", Let("sugar_if_scrutinee", App(Force(Var("pred")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ret(Inj2(Var("n"))), Ret(Inj1(Unit))))))), clas: Ok(Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Lam("opnat", Der { ctx: Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), dir: Check(Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), term: Lam("pred", Case(Var("opnat"), "_u", Ret(Inj1(Unit)), "n", Let("sugar_if_scrutinee", App(Force(Var("pred")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ret(Inj2(Var("n"))), Ret(Inj1(Unit)))))), clas: Ok(Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Lam("pred", Der { ctx: Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Case(Var("opnat"), "_u", Ret(Inj1(Unit)), "n", Let("sugar_if_scrutinee", App(Force(Var("pred")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ret(Inj2(Var("n"))), Ret(Inj1(Unit))))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Case(Der { ctx: Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: Var("opnat"), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Var("opnat"), vis: DerVis { tmfam: "Val", local_err: false } }, "_u", Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "_u", Unit), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Inj1(Unit)), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "_u", Unit), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj1(Unit), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj1(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "_u", Unit), dir: Check(Unit), term: Unit, clas: Ok(Unit), rule: Unit, vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, "n", Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Let("sugar_if_scrutinee", App(Force(Var("pred")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ret(Inj2(Var("n"))), Ret(Inj1(Unit)))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Let("sugar_if_scrutinee", Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: App(Force(Var("pred")), Var("n")), clas: Ok(Cons(Lift(Prim(Bool)), WR(Empty, Empty))), rule: App(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: Force(Var("pred")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: Force(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: Var("pred"), clas: Ok(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), rule: Var("pred"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: IfThenElse(Var("sugar_if_scrutinee"), Ret(Inj2(Var("n"))), Ret(Inj1(Unit))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: IfThenElse(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("sugar_if_scrutinee"), clas: Ok(Prim(Bool)), rule: Var("sugar_if_scrutinee"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Inj2(Var("n"))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj2(Var("n")), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj2(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Prim(Nat)), term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Inj1(Unit)), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj1(Unit), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj1(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "pred", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Unit), term: Unit, clas: Ok(Unit), rule: Unit, vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: None, qual: Val, var: "opnat_max", der: Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Ident("OpNat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("opnat_max", Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Ident("OpNat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(Fix("opnat_max", Lam("xo", Lam("yo", Case(Var("xo"), "_u", Ret(Var("yo")), "x", Case(Var("yo"), "_u", Ret(Var("yo")), "y", Let("sugar_if_scrutinee", PrimApp(NatLt(Var("x"), Var("y"))), IfThenElse(Var("sugar_if_scrutinee"), Ret(Var("yo")), Ret(Var("xo")))))))))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("OpNat"), Cons(Arrow(Ident("OpNat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), term: Fix("opnat_max", Lam("xo", Lam("yo", Case(Var("xo"), "_u", Ret(Var("yo")), "x", Case(Var("yo"), "_u", Ret(Var("yo")), "y", Let("sugar_if_scrutinee", PrimApp(NatLt(Var("x"), Var("y"))), IfThenElse(Var("sugar_if_scrutinee"), Ret(Var("yo")), Ret(Var("xo"))))))))), clas: Ok(Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Fix("opnat_max", Der { ctx: Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), term: Lam("xo", Lam("yo", Case(Var("xo"), "_u", Ret(Var("yo")), "x", Case(Var("yo"), "_u", Ret(Var("yo")), "y", Let("sugar_if_scrutinee", PrimApp(NatLt(Var("x"), Var("y"))), IfThenElse(Var("sugar_if_scrutinee"), Ret(Var("yo")), Ret(Var("xo")))))))), clas: Ok(Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Lam("xo", Der { ctx: Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), dir: Check(Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), term: Lam("yo", Case(Var("xo"), "_u", Ret(Var("yo")), "x", Case(Var("yo"), "_u", Ret(Var("yo")), "y", Let("sugar_if_scrutinee", PrimApp(NatLt(Var("x"), Var("y"))), IfThenElse(Var("sugar_if_scrutinee"), Ret(Var("yo")), Ret(Var("xo"))))))), clas: Ok(Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Lam("yo", Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Case(Var("xo"), "_u", Ret(Var("yo")), "x", Case(Var("yo"), "_u", Ret(Var("yo")), "y", Let("sugar_if_scrutinee", PrimApp(NatLt(Var("x"), Var("y"))), IfThenElse(Var("sugar_if_scrutinee"), Ret(Var("yo")), Ret(Var("xo")))))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Case(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), dir: Synth, term: Var("xo"), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Var("xo"), vis: DerVis { tmfam: "Val", local_err: false } }, "_u", Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "_u", Unit), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Var("yo")), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "_u", Unit), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Var("yo"), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Var("yo"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, "x", Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Case(Var("yo"), "_u", Ret(Var("yo")), "y", Let("sugar_if_scrutinee", PrimApp(NatLt(Var("x"), Var("y"))), IfThenElse(Var("sugar_if_scrutinee"), Ret(Var("yo")), Ret(Var("xo"))))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Case(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), dir: Synth, term: Var("yo"), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Var("yo"), vis: DerVis { tmfam: "Val", local_err: false } }, "_u", Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "_u", Unit), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Var("yo")), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "_u", Unit), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Var("yo"), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Var("yo"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, "y", Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Let("sugar_if_scrutinee", PrimApp(NatLt(Var("x"), Var("y"))), IfThenElse(Var("sugar_if_scrutinee"), Ret(Var("yo")), Ret(Var("xo")))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Let("sugar_if_scrutinee", Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Synth, term: PrimApp(NatLt(Var("x"), Var("y"))), clas: Ok(Cons(Lift(Prim(Bool)), WR(Empty, Empty))), rule: PrimApp(NatLt(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Synth, term: Var("x"), clas: Ok(Prim(Nat)), rule: Var("x"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), dir: Synth, term: Var("y"), clas: Ok(Prim(Nat)), rule: Var("y"), vis: DerVis { tmfam: "Val", local_err: false } })), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: IfThenElse(Var("sugar_if_scrutinee"), Ret(Var("yo")), Ret(Var("xo"))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: IfThenElse(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("sugar_if_scrutinee"), clas: Ok(Prim(Bool)), rule: Var("sugar_if_scrutinee"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Var("yo")), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Var("yo"), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Var("yo"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Var("xo")), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "xo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "yo", IdentDef("OpNat", Sum(Unit, Prim(Nat)))), "x", Prim(Nat)), "y", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Var("xo"), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Var("xo"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" If the given number is even, return its successor\""), qual: Val, var: "nat_succ_even", der: Der { ctx: Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_succ_even", Der { ctx: Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(Fix("nat_succ_even", Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), term: Fix("nat_succ_even", Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit)))))), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Fix("nat_succ_even", Der { ctx: Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), term: Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Lam("n", Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit)))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Let("sugar_if_scrutinee", Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: App(Force(Var("nat_is_odd")), Var("n")), clas: Ok(Cons(Lift(Prim(Bool)), WR(Empty, Empty))), rule: App(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: Force(Var("nat_is_odd")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: Force(Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: Var("nat_is_odd"), clas: Ok(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), rule: Var("nat_is_odd"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: IfThenElse(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("sugar_if_scrutinee"), clas: Ok(Prim(Bool)), rule: Var("sugar_if_scrutinee"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Let("m", Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: PrimApp(NatPlus(Var("n"), Nat(1))), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: PrimApp(NatPlus(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Nat(1), clas: Ok(Prim(Nat)), rule: Nat(1), vis: DerVis { tmfam: "Val", local_err: false } })), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Inj2(Var("m"))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj2(Var("m")), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj2(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("m"), clas: Ok(Prim(Nat)), rule: Var("m"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Inj1(Unit)), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj1(Unit), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj1(Der { ctx: Var(Var(Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Unit), term: Unit, clas: Ok(Unit), rule: Unit, vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } })], ctx_out: Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))) } }, Der { ctx: Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: Ret(Nat(0)), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Var(Def(Def(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "Op2Nat", Type(Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), "opnat_split", Thk(Empty, Cons(Arrow(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat)))), Cons(Lift(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_pair", Thk(Empty, Cons(Arrow(Prod(IdentDef("OpNat", Sum(Unit, Prim(Nat))), IdentDef("OpNat", Sum(Unit, Prim(Nat)))), Cons(Lift(IdentDef("Op2Nat", Sum(Unit, Prod(Prim(Nat), Prim(Nat))))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_filter_nat", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "opnat_max", Thk(Empty, Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Arrow(IdentDef("OpNat", Sum(Unit, Prim(Nat))), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: Nat(0), clas: Ok(Prim(Nat)), rule: Nat(0), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, traces: [] }