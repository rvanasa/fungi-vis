Bundle { input: "open crate :: examples :: name ; ret 0", program: Der { ctx: Empty, dir: Synth, term: UseAll(UseAllModule { path: "crate::examples::name", module: Module { path: "fungi_lang::examples::name", body: "# [doc = r\" Convert a natural number into a name\"] fn name_of_nat :\n(Thk [0] foralli X : NmSet . 0 Nat -> 0 F Nm [X]) =\n{ unsafe (1) trapdoor :: name_of_nat } #\n[doc = r\" Test if two names are equal\"] fn name_eq :\n(Thk [0] foralli (X, Y) : NmSet . 0 Nm [X] -> 0 Nm [Y] -> 0 F Bool) =\n{ unsafe (2) trapdoor :: name_eq }", decls: Doc("r\" Convert a natural number into a name\"", Fn("name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), HostFn(HostEvalFn("trapdoor::name_of_nat")), Doc("r\" Test if two names are equal\"", Fn("name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), HostFn(HostEvalFn("trapdoor::name_eq")), End)))) } }, Ret(Nat(0))), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: UseAll(UseAllModuleDer { ast: UseAllModule { path: "crate::examples::name", module: Module { path: "fungi_lang::examples::name", body: "# [doc = r\" Convert a natural number into a name\"] fn name_of_nat :\n(Thk [0] foralli X : NmSet . 0 Nat -> 0 F Nm [X]) =\n{ unsafe (1) trapdoor :: name_of_nat } #\n[doc = r\" Test if two names are equal\"] fn name_eq :\n(Thk [0] foralli (X, Y) : NmSet . 0 Nm [X] -> 0 Nm [Y] -> 0 F Bool) =\n{ unsafe (2) trapdoor :: name_eq }", decls: Doc("r\" Convert a natural number into a name\"", Fn("name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), HostFn(HostEvalFn("trapdoor::name_of_nat")), Doc("r\" Test if two names are equal\"", Fn("name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), HostFn(HostEvalFn("trapdoor::name_eq")), End)))) } }, der: ModuleDer { ast: Module { path: "fungi_lang::examples::name", body: "# [doc = r\" Convert a natural number into a name\"] fn name_of_nat :\n(Thk [0] foralli X : NmSet . 0 Nat -> 0 F Nm [X]) =\n{ unsafe (1) trapdoor :: name_of_nat } #\n[doc = r\" Test if two names are equal\"] fn name_eq :\n(Thk [0] foralli (X, Y) : NmSet . 0 Nm [X] -> 0 Nm [Y] -> 0 F Bool) =\n{ unsafe (2) trapdoor :: name_eq }", decls: Doc("r\" Convert a natural number into a name\"", Fn("name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), HostFn(HostEvalFn("trapdoor::name_of_nat")), Doc("r\" Test if two names are equal\"", Fn("name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), HostFn(HostEvalFn("trapdoor::name_eq")), End)))) }, tds: [Bind(ItemDer { doc: Some("r\" Convert a natural number into a name\""), qual: Val, var: "name_of_nat", der: Der { ctx: Empty, dir: Synth, term: (), clas: Ok(Type(Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))))), rule: Fn("name_of_nat", Der { ctx: Empty, dir: Check(Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::name_of_nat"))), clas: Ok(Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: ThunkAnon(Der { ctx: Empty, dir: Check(ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), term: HostFn(HostEvalFn("trapdoor::name_of_nat")), clas: Ok(ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), rule: HostFn(HostEvalFn("trapdoor::name_of_nat")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Test if two names are equal\""), qual: Val, var: "name_eq", der: Der { ctx: Var(Empty, "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))))), rule: Fn("name_eq", Der { ctx: Var(Empty, "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), dir: Check(Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::name_eq"))), clas: Ok(Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), rule: ThunkAnon(Der { ctx: Var(Empty, "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), dir: Check(ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), term: HostFn(HostEvalFn("trapdoor::name_eq")), clas: Ok(ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: HostFn(HostEvalFn("trapdoor::name_eq")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } })], ctx_out: Var(Var(Empty, "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))) } }, Der { ctx: Var(Var(Empty, "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), dir: Synth, term: Ret(Nat(0)), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Empty, "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), dir: Synth, term: Nat(0), clas: Ok(Prim(Nat)), rule: Nat(0), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, traces: [] }