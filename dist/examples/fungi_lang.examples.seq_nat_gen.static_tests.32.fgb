Bundle { input: "open crate :: examples :: seq_nat_gen ; ret 0", program: Der { ctx: Empty, dir: Synth, term: UseAll(UseAllModule { path: "crate::examples::seq_nat_gen", module: Module { path: "fungi_lang::examples::seq_nat_gen", body: "open crate :: examples :: seq_nat ; open crate :: examples :: name ; open\ncrate :: examples :: nat ; #\n[doc = r\" Generate a sequence of natural numbers\"] fn seq_gen :\n(Thk [0] foralli (Y1, X1, Y2) : NmSet . 0 Nat -> 0 F Ref [Y1] (Seq [X1] [Y2]))\n=\n{\n    # n . if { { force nat_is_zero } n } { ref (@ 0) roll inj1 () } else\n    {\n        let nm = { { force name_of_nat } n } let pred =\n        { { force nat_sub } n 1 } let seq_ref = { { force seq_gen } pred } let\n        leaf_ref = { ref nm roll inj2 inj1 (nm, n) } let nmb =\n        { nm, (@ @ bin) } ref nmb roll inj2 inj2 pack (?, ?, ?)\n        (nmb, n, leaf_ref, seq_ref)\n    }\n}", decls: UseAll(UseAllModule { path: "crate::examples::seq_nat", module: Module { path: "fungi_lang::examples::seq_nat", body: "type Lev = (Nat) ; # [doc = r\" Level trees of natural numbers\"] type Seq =\n(rec seq . foralli (X, Y) : NmSet .\n (+ Unit + (x Nm [X] x Nat)\n  (exists (X1, X2, X3) : NmSet | ((X1 % X2 % X3) = X : NmSet) . x Nm [X1] x\n   Lev x Ref [Y] (seq [X2] [Y]) x Ref [Y] (seq [X3] [Y])))) ; #\n[doc = r\" References to sequences of natural numbers\"] type RefSeq =\n(foralli (X, Y) : NmSet . Ref [Y] (Seq [X] [Y])) ;", decls: Type("Lev", Ident("Nat"), Doc("r\" Level trees of natural numbers\"", Type("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Ident("Nat")), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(Ident("Lev"), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Doc("r\" References to sequences of natural numbers\"", Type("RefSeq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(Ident("Seq"), Var("X")), Var("Y"))))), End))))) } }, UseAll(UseAllModule { path: "crate::examples::name", module: Module { path: "fungi_lang::examples::name", body: "# [doc = r\" Convert a natural number into a name\"] fn name_of_nat :\n(Thk [0] foralli X : NmSet . 0 Nat -> 0 F Nm [X]) =\n{ unsafe (1) trapdoor :: name_of_nat } #\n[doc = r\" Test if two names are equal\"] fn name_eq :\n(Thk [0] foralli (X, Y) : NmSet . 0 Nm [X] -> 0 Nm [Y] -> 0 F Bool) =\n{ unsafe (2) trapdoor :: name_eq }", decls: Doc("r\" Convert a natural number into a name\"", Fn("name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), HostFn(HostEvalFn("trapdoor::name_of_nat")), Doc("r\" Test if two names are equal\"", Fn("name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), HostFn(HostEvalFn("trapdoor::name_eq")), End)))) } }, UseAll(UseAllModule { path: "crate::examples::nat", module: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) } }, Doc("r\" Generate a sequence of natural numbers\"", Fn("seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(Ident("Seq"), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty)))))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_zero")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ref(Name(Num(0)), Roll(Inj1(Unit))), Let("nm", App(Force(Var("name_of_nat")), Var("n")), Let("pred", App(App(Force(Var("nat_sub")), Var("n")), Nat(1)), Let("seq_ref", App(Force(Var("seq_gen")), Var("pred")), Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))))))))))))))))), End))))) } }, Ret(Nat(0))), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: UseAll(UseAllModuleDer { ast: UseAllModule { path: "crate::examples::seq_nat_gen", module: Module { path: "fungi_lang::examples::seq_nat_gen", body: "open crate :: examples :: seq_nat ; open crate :: examples :: name ; open\ncrate :: examples :: nat ; #\n[doc = r\" Generate a sequence of natural numbers\"] fn seq_gen :\n(Thk [0] foralli (Y1, X1, Y2) : NmSet . 0 Nat -> 0 F Ref [Y1] (Seq [X1] [Y2]))\n=\n{\n    # n . if { { force nat_is_zero } n } { ref (@ 0) roll inj1 () } else\n    {\n        let nm = { { force name_of_nat } n } let pred =\n        { { force nat_sub } n 1 } let seq_ref = { { force seq_gen } pred } let\n        leaf_ref = { ref nm roll inj2 inj1 (nm, n) } let nmb =\n        { nm, (@ @ bin) } ref nmb roll inj2 inj2 pack (?, ?, ?)\n        (nmb, n, leaf_ref, seq_ref)\n    }\n}", decls: UseAll(UseAllModule { path: "crate::examples::seq_nat", module: Module { path: "fungi_lang::examples::seq_nat", body: "type Lev = (Nat) ; # [doc = r\" Level trees of natural numbers\"] type Seq =\n(rec seq . foralli (X, Y) : NmSet .\n (+ Unit + (x Nm [X] x Nat)\n  (exists (X1, X2, X3) : NmSet | ((X1 % X2 % X3) = X : NmSet) . x Nm [X1] x\n   Lev x Ref [Y] (seq [X2] [Y]) x Ref [Y] (seq [X3] [Y])))) ; #\n[doc = r\" References to sequences of natural numbers\"] type RefSeq =\n(foralli (X, Y) : NmSet . Ref [Y] (Seq [X] [Y])) ;", decls: Type("Lev", Ident("Nat"), Doc("r\" Level trees of natural numbers\"", Type("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Ident("Nat")), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(Ident("Lev"), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Doc("r\" References to sequences of natural numbers\"", Type("RefSeq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(Ident("Seq"), Var("X")), Var("Y"))))), End))))) } }, UseAll(UseAllModule { path: "crate::examples::name", module: Module { path: "fungi_lang::examples::name", body: "# [doc = r\" Convert a natural number into a name\"] fn name_of_nat :\n(Thk [0] foralli X : NmSet . 0 Nat -> 0 F Nm [X]) =\n{ unsafe (1) trapdoor :: name_of_nat } #\n[doc = r\" Test if two names are equal\"] fn name_eq :\n(Thk [0] foralli (X, Y) : NmSet . 0 Nm [X] -> 0 Nm [Y] -> 0 F Bool) =\n{ unsafe (2) trapdoor :: name_eq }", decls: Doc("r\" Convert a natural number into a name\"", Fn("name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), HostFn(HostEvalFn("trapdoor::name_of_nat")), Doc("r\" Test if two names are equal\"", Fn("name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), HostFn(HostEvalFn("trapdoor::name_eq")), End)))) } }, UseAll(UseAllModule { path: "crate::examples::nat", module: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) } }, Doc("r\" Generate a sequence of natural numbers\"", Fn("seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(Ident("Seq"), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty)))))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_zero")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ref(Name(Num(0)), Roll(Inj1(Unit))), Let("nm", App(Force(Var("name_of_nat")), Var("n")), Let("pred", App(App(Force(Var("nat_sub")), Var("n")), Nat(1)), Let("seq_ref", App(Force(Var("seq_gen")), Var("pred")), Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))))))))))))))))), End))))) } }, der: ModuleDer { ast: Module { path: "fungi_lang::examples::seq_nat_gen", body: "open crate :: examples :: seq_nat ; open crate :: examples :: name ; open\ncrate :: examples :: nat ; #\n[doc = r\" Generate a sequence of natural numbers\"] fn seq_gen :\n(Thk [0] foralli (Y1, X1, Y2) : NmSet . 0 Nat -> 0 F Ref [Y1] (Seq [X1] [Y2]))\n=\n{\n    # n . if { { force nat_is_zero } n } { ref (@ 0) roll inj1 () } else\n    {\n        let nm = { { force name_of_nat } n } let pred =\n        { { force nat_sub } n 1 } let seq_ref = { { force seq_gen } pred } let\n        leaf_ref = { ref nm roll inj2 inj1 (nm, n) } let nmb =\n        { nm, (@ @ bin) } ref nmb roll inj2 inj2 pack (?, ?, ?)\n        (nmb, n, leaf_ref, seq_ref)\n    }\n}", decls: UseAll(UseAllModule { path: "crate::examples::seq_nat", module: Module { path: "fungi_lang::examples::seq_nat", body: "type Lev = (Nat) ; # [doc = r\" Level trees of natural numbers\"] type Seq =\n(rec seq . foralli (X, Y) : NmSet .\n (+ Unit + (x Nm [X] x Nat)\n  (exists (X1, X2, X3) : NmSet | ((X1 % X2 % X3) = X : NmSet) . x Nm [X1] x\n   Lev x Ref [Y] (seq [X2] [Y]) x Ref [Y] (seq [X3] [Y])))) ; #\n[doc = r\" References to sequences of natural numbers\"] type RefSeq =\n(foralli (X, Y) : NmSet . Ref [Y] (Seq [X] [Y])) ;", decls: Type("Lev", Ident("Nat"), Doc("r\" Level trees of natural numbers\"", Type("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Ident("Nat")), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(Ident("Lev"), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Doc("r\" References to sequences of natural numbers\"", Type("RefSeq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(Ident("Seq"), Var("X")), Var("Y"))))), End))))) } }, UseAll(UseAllModule { path: "crate::examples::name", module: Module { path: "fungi_lang::examples::name", body: "# [doc = r\" Convert a natural number into a name\"] fn name_of_nat :\n(Thk [0] foralli X : NmSet . 0 Nat -> 0 F Nm [X]) =\n{ unsafe (1) trapdoor :: name_of_nat } #\n[doc = r\" Test if two names are equal\"] fn name_eq :\n(Thk [0] foralli (X, Y) : NmSet . 0 Nm [X] -> 0 Nm [Y] -> 0 F Bool) =\n{ unsafe (2) trapdoor :: name_eq }", decls: Doc("r\" Convert a natural number into a name\"", Fn("name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), HostFn(HostEvalFn("trapdoor::name_of_nat")), Doc("r\" Test if two names are equal\"", Fn("name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), HostFn(HostEvalFn("trapdoor::name_eq")), End)))) } }, UseAll(UseAllModule { path: "crate::examples::nat", module: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) } }, Doc("r\" Generate a sequence of natural numbers\"", Fn("seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(Ident("Seq"), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty)))))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_zero")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ref(Name(Num(0)), Roll(Inj1(Unit))), Let("nm", App(Force(Var("name_of_nat")), Var("n")), Let("pred", App(App(Force(Var("nat_sub")), Var("n")), Nat(1)), Let("seq_ref", App(Force(Var("seq_gen")), Var("pred")), Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))))))))))))))))), End))))) }, tds: [UseAll(UseAllModuleDer { ast: UseAllModule { path: "crate::examples::seq_nat", module: Module { path: "fungi_lang::examples::seq_nat", body: "type Lev = (Nat) ; # [doc = r\" Level trees of natural numbers\"] type Seq =\n(rec seq . foralli (X, Y) : NmSet .\n (+ Unit + (x Nm [X] x Nat)\n  (exists (X1, X2, X3) : NmSet | ((X1 % X2 % X3) = X : NmSet) . x Nm [X1] x\n   Lev x Ref [Y] (seq [X2] [Y]) x Ref [Y] (seq [X3] [Y])))) ; #\n[doc = r\" References to sequences of natural numbers\"] type RefSeq =\n(foralli (X, Y) : NmSet . Ref [Y] (Seq [X] [Y])) ;", decls: Type("Lev", Ident("Nat"), Doc("r\" Level trees of natural numbers\"", Type("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Ident("Nat")), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(Ident("Lev"), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Doc("r\" References to sequences of natural numbers\"", Type("RefSeq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(Ident("Seq"), Var("X")), Var("Y"))))), End))))) } }, der: ModuleDer { ast: Module { path: "fungi_lang::examples::seq_nat", body: "type Lev = (Nat) ; # [doc = r\" Level trees of natural numbers\"] type Seq =\n(rec seq . foralli (X, Y) : NmSet .\n (+ Unit + (x Nm [X] x Nat)\n  (exists (X1, X2, X3) : NmSet | ((X1 % X2 % X3) = X : NmSet) . x Nm [X1] x\n   Lev x Ref [Y] (seq [X2] [Y]) x Ref [Y] (seq [X3] [Y])))) ; #\n[doc = r\" References to sequences of natural numbers\"] type RefSeq =\n(foralli (X, Y) : NmSet . Ref [Y] (Seq [X] [Y])) ;", decls: Type("Lev", Ident("Nat"), Doc("r\" Level trees of natural numbers\"", Type("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Ident("Nat")), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(Ident("Lev"), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Doc("r\" References to sequences of natural numbers\"", Type("RefSeq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(Ident("Seq"), Var("X")), Var("Y"))))), End))))) }, tds: [Bind(ItemDer { doc: None, qual: Type, var: "Lev", der: Der { ctx: Empty, dir: Synth, term: (), clas: Ok(Kind(NoParse("TODO-XXX-bitype.rs"))), rule: Type("Lev", Prim(Nat)), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Level trees of natural numbers\""), qual: Type, var: "Seq", der: Der { ctx: Def(Empty, "Lev", Type(Prim(Nat))), dir: Synth, term: (), clas: Ok(Kind(NoParse("TODO-XXX-bitype.rs"))), rule: Type("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" References to sequences of natural numbers\""), qual: Type, var: "RefSeq", der: Der { ctx: Def(Def(Empty, "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), dir: Synth, term: (), clas: Ok(Kind(NoParse("TODO-XXX-bitype.rs"))), rule: Type("RefSeq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y")))))), vis: DerVis { tmfam: "Module", local_err: false } } })], ctx_out: Def(Def(Def(Empty, "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))) } }), UseAll(UseAllModuleDer { ast: UseAllModule { path: "crate::examples::name", module: Module { path: "fungi_lang::examples::name", body: "# [doc = r\" Convert a natural number into a name\"] fn name_of_nat :\n(Thk [0] foralli X : NmSet . 0 Nat -> 0 F Nm [X]) =\n{ unsafe (1) trapdoor :: name_of_nat } #\n[doc = r\" Test if two names are equal\"] fn name_eq :\n(Thk [0] foralli (X, Y) : NmSet . 0 Nm [X] -> 0 Nm [Y] -> 0 F Bool) =\n{ unsafe (2) trapdoor :: name_eq }", decls: Doc("r\" Convert a natural number into a name\"", Fn("name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), HostFn(HostEvalFn("trapdoor::name_of_nat")), Doc("r\" Test if two names are equal\"", Fn("name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), HostFn(HostEvalFn("trapdoor::name_eq")), End)))) } }, der: ModuleDer { ast: Module { path: "fungi_lang::examples::name", body: "# [doc = r\" Convert a natural number into a name\"] fn name_of_nat :\n(Thk [0] foralli X : NmSet . 0 Nat -> 0 F Nm [X]) =\n{ unsafe (1) trapdoor :: name_of_nat } #\n[doc = r\" Test if two names are equal\"] fn name_eq :\n(Thk [0] foralli (X, Y) : NmSet . 0 Nm [X] -> 0 Nm [Y] -> 0 F Bool) =\n{ unsafe (2) trapdoor :: name_eq }", decls: Doc("r\" Convert a natural number into a name\"", Fn("name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), HostFn(HostEvalFn("trapdoor::name_of_nat")), Doc("r\" Test if two names are equal\"", Fn("name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), HostFn(HostEvalFn("trapdoor::name_eq")), End)))) }, tds: [Bind(ItemDer { doc: Some("r\" Convert a natural number into a name\""), qual: Val, var: "name_of_nat", der: Der { ctx: Empty, dir: Synth, term: (), clas: Ok(Type(Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))))), rule: Fn("name_of_nat", Der { ctx: Empty, dir: Check(Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::name_of_nat"))), clas: Ok(Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: ThunkAnon(Der { ctx: Empty, dir: Check(ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), term: HostFn(HostEvalFn("trapdoor::name_of_nat")), clas: Ok(ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), rule: HostFn(HostEvalFn("trapdoor::name_of_nat")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Test if two names are equal\""), qual: Val, var: "name_eq", der: Der { ctx: Var(Empty, "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))))), rule: Fn("name_eq", Der { ctx: Var(Empty, "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), dir: Check(Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::name_eq"))), clas: Ok(Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), rule: ThunkAnon(Der { ctx: Var(Empty, "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), dir: Check(ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), term: HostFn(HostEvalFn("trapdoor::name_eq")), clas: Ok(ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: HostFn(HostEvalFn("trapdoor::name_eq")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } })], ctx_out: Var(Var(Empty, "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))) } }), UseAll(UseAllModuleDer { ast: UseAllModule { path: "crate::examples::nat", module: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) } }, der: ModuleDer { ast: Module { path: "fungi_lang::examples::nat", body: "#\n[doc = r\" Return true if the given natural number is zero, false otherwise.\"]\nfn nat_is_zero : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_zero } #\n[doc = r\" Return true if the given natural number is odd, false otherwise.\"]\nfn nat_is_odd : (Thk [0] 0 Nat -> 0 F Bool) =\n{ unsafe (1) trapdoor :: nat_is_odd } #\n[doc = r\" Return the difference of two natural numbers, as a natural number.\"]\nfn nat_sub : (Thk [0] 0 Nat -> 0 Nat -> 0 F Nat) =\n{ unsafe (2) trapdoor :: nat_sub } # [doc = r\" Optional natural numbers\"] type\nOpNat = (+ Unit + Nat) ; #\n[doc = r\" If the given number is even, return its successor\"] fn nat_succ_even\n: (Thk [0] 0 Nat -> 0 F OpNat) =\n{\n    # n . if { { force nat_is_odd } n } { let m = { n + 1 } ret inj2 m } else\n    { ret inj1 () }\n}", decls: Doc("r\" Return true if the given natural number is zero, false otherwise.\"", Fn("nat_is_zero", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_zero")), Doc("r\" Return true if the given natural number is odd, false otherwise.\"", Fn("nat_is_odd", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_is_odd")), Doc("r\" Return the difference of two natural numbers, as a natural number.\"", Fn("nat_sub", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), HostFn(HostEvalFn("trapdoor::nat_sub")), Doc("r\" Optional natural numbers\"", Type("OpNat", Sum(Unit, Ident("Nat")), Doc("r\" If the given number is even, return its successor\"", Fn("nat_succ_even", Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))), Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), End)))))))))) }, tds: [Bind(ItemDer { doc: Some("r\" Return true if the given natural number is zero, false otherwise.\""), qual: Val, var: "nat_is_zero", der: Der { ctx: Empty, dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_is_zero", Der { ctx: Empty, dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::nat_is_zero"))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Empty, dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), term: HostFn(HostEvalFn("trapdoor::nat_is_zero")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: HostFn(HostEvalFn("trapdoor::nat_is_zero")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Return true if the given natural number is odd, false otherwise.\""), qual: Val, var: "nat_is_odd", der: Der { ctx: Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_is_odd", Der { ctx: Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::nat_is_odd"))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Bool")), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), term: HostFn(HostEvalFn("trapdoor::nat_is_odd")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: HostFn(HostEvalFn("trapdoor::nat_is_odd")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Return the difference of two natural numbers, as a natural number.\""), qual: Val, var: "nat_sub", der: Der { ctx: Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_sub", Der { ctx: Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(HostFn(HostEvalFn("trapdoor::nat_sub"))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("Nat")), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), term: HostFn(HostEvalFn("trapdoor::nat_sub")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), rule: HostFn(HostEvalFn("trapdoor::nat_sub")), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" Optional natural numbers\""), qual: Type, var: "OpNat", der: Der { ctx: Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Synth, term: (), clas: Ok(Kind(NoParse("TODO-XXX-bitype.rs"))), rule: Type("OpNat", Sum(Unit, Prim(Nat))), vis: DerVis { tmfam: "Module", local_err: false } } }), Bind(ItemDer { doc: Some("r\" If the given number is even, return its successor\""), qual: Val, var: "nat_succ_even", der: Der { ctx: Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), dir: Synth, term: (), clas: Ok(Type(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Fn("nat_succ_even", Der { ctx: Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), dir: Check(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty)))), term: ThunkAnon(Fix("nat_succ_even", Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))))), clas: Ok(Thk(Empty, Cons(Arrow(Ident("Nat"), Cons(Lift(Ident("OpNat")), WR(Empty, Empty))), WR(Empty, Empty)))), rule: ThunkAnon(Der { ctx: Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), term: Fix("nat_succ_even", Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit)))))), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Fix("nat_succ_even", Der { ctx: Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), dir: Check(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), term: Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))))), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Lam("n", Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Let("sugar_if_scrutinee", App(Force(Var("nat_is_odd")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit)))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Let("sugar_if_scrutinee", Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: App(Force(Var("nat_is_odd")), Var("n")), clas: Ok(Cons(Lift(Prim(Bool)), WR(Empty, Empty))), rule: App(Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: Force(Var("nat_is_odd")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: Force(Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Synth, term: Var("nat_is_odd"), clas: Ok(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), rule: Var("nat_is_odd"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: IfThenElse(Var("sugar_if_scrutinee"), Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), Ret(Inj1(Unit))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: IfThenElse(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("sugar_if_scrutinee"), clas: Ok(Prim(Bool)), rule: Var("sugar_if_scrutinee"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Let("m", PrimApp(NatPlus(Var("n"), Nat(1))), Ret(Inj2(Var("m")))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Let("m", Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: PrimApp(NatPlus(Var("n"), Nat(1))), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: PrimApp(NatPlus(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Nat(1), clas: Ok(Prim(Nat)), rule: Nat(1), vis: DerVis { tmfam: "Val", local_err: false } })), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Inj2(Var("m"))), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj2(Var("m")), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj2(Der { ctx: Var(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "m", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("m"), clas: Ok(Prim(Nat)), rule: Var("m"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), term: Ret(Inj1(Unit)), clas: Ok(Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), term: Inj1(Unit), clas: Ok(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), rule: Inj1(Der { ctx: Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Unit), term: Unit, clas: Ok(Unit), rule: Unit, vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } })], ctx_out: Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))) } }), Bind(ItemDer { doc: Some("r\" Generate a sequence of natural numbers\""), qual: Val, var: "seq_gen", der: Der { ctx: Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), dir: Synth, term: (), clas: Err(CheckFailCEffect(ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), rule: Fn("seq_gen", Der { ctx: Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), dir: Check(Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Ident("Nat"), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(Ident("Seq"), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), term: ThunkAnon(Fix("seq_gen", Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_zero")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ref(Name(Num(0)), Roll(Inj1(Unit))), Let("nm", App(Force(Var("name_of_nat")), Var("n")), Let("pred", App(App(Force(Var("nat_sub")), Var("n")), Nat(1)), Let("seq_ref", App(Force(Var("seq_gen")), Var("pred")), Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))))))))))))))))))), clas: Err(CheckFailCEffect(ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), rule: ThunkAnon(Der { ctx: Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), dir: Check(ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty)))))), term: Fix("seq_gen", Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_zero")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ref(Name(Num(0)), Roll(Inj1(Unit))), Let("nm", App(Force(Var("name_of_nat")), Var("n")), Let("pred", App(App(Force(Var("nat_sub")), Var("n")), Nat(1)), Let("seq_ref", App(Force(Var("seq_gen")), Var("pred")), Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref")))))))))))))))))))), clas: Err(CheckFailCEffect(ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), rule: Fix("seq_gen", Der { ctx: Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), dir: Check(ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty)))))), term: Lam("n", Let("sugar_if_scrutinee", App(Force(Var("nat_is_zero")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ref(Name(Num(0)), Roll(Inj1(Unit))), Let("nm", App(Force(Var("name_of_nat")), Var("n")), Let("pred", App(App(Force(Var("nat_sub")), Var("n")), Nat(1)), Let("seq_ref", App(Force(Var("seq_gen")), Var("pred")), Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))))))))))))))))), clas: Err(CheckFailCEffect(Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty)))), rule: Lam("n", Der { ctx: Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), dir: Check(Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), term: Let("sugar_if_scrutinee", App(Force(Var("nat_is_zero")), Var("n")), IfThenElse(Var("sugar_if_scrutinee"), Ref(Name(Num(0)), Roll(Inj1(Unit))), Let("nm", App(Force(Var("name_of_nat")), Var("n")), Let("pred", App(App(Force(Var("nat_sub")), Var("n")), Nat(1)), Let("seq_ref", App(Force(Var("seq_gen")), Var("pred")), Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref")))))))))))))))))), clas: Err(Later(ParamNoCheck(2))), rule: Let("sugar_if_scrutinee", Der { ctx: Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), dir: Synth, term: App(Force(Var("nat_is_zero")), Var("n")), clas: Ok(Cons(Lift(Prim(Bool)), WR(Empty, Empty))), rule: App(Der { ctx: Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), dir: Synth, term: Force(Var("nat_is_zero")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), rule: Force(Der { ctx: Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), dir: Synth, term: Var("nat_is_zero"), clas: Ok(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), rule: Var("nat_is_zero"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), dir: Check(Prim(Nat)), term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), term: IfThenElse(Var("sugar_if_scrutinee"), Ref(Name(Num(0)), Roll(Inj1(Unit))), Let("nm", App(Force(Var("name_of_nat")), Var("n")), Let("pred", App(App(Force(Var("nat_sub")), Var("n")), Nat(1)), Let("seq_ref", App(Force(Var("seq_gen")), Var("pred")), Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))))))))))))))), clas: Err(ParamNoCheck(2)), rule: IfThenElse(Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("sugar_if_scrutinee"), clas: Ok(Prim(Bool)), rule: Var("sugar_if_scrutinee"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), term: Ref(Name(Num(0)), Roll(Inj1(Unit))), clas: Ok(Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), rule: Ref(Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Name(Num(0)), clas: Ok(Nm(Sing(Name(Num(0))))), rule: Name(Num(0)), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2"))), term: Roll(Inj1(Unit)), clas: Ok(IdxApp(IdxApp(IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Var("X3")), Var("Y"))))))))))))), Var("X1")), Var("Y2"))), rule: Roll(Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(IdxApp(IdxApp(IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Var("X3")), Var("Y"))))))))))))), Var("X1")), Var("Y2"))), term: Inj1(Unit), clas: Ok(IdxApp(IdxApp(IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))), Var("X3")), Var("Y"))))))))))))), Var("X1")), Var("Y2"))), rule: Inj1(Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Unit), term: Unit, clas: Ok(Unit), rule: Unit, vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), term: Let("nm", App(Force(Var("name_of_nat")), Var("n")), Let("pred", App(App(Force(Var("nat_sub")), Var("n")), Nat(1)), Let("seq_ref", App(Force(Var("seq_gen")), Var("pred")), Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref")))))))))))))))), clas: Err(UnexpectedCEffect(ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Let("nm", Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: App(Force(Var("name_of_nat")), Var("n")), clas: Err(UnexpectedCEffect(ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: App(Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Force(Var("name_of_nat")), clas: Ok(ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty)))), rule: Force(Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("name_of_nat"), clas: Ok(Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), rule: Var("name_of_nat"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: true } }, Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Let("pred", App(App(Force(Var("nat_sub")), Var("n")), Nat(1)), Let("seq_ref", App(Force(Var("seq_gen")), Var("pred")), Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))))))))))))), clas: Err(Later(ParamNoSynth(1))), rule: Let("pred", Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: App(App(Force(Var("nat_sub")), Var("n")), Nat(1)), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: App(Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: App(Force(Var("nat_sub")), Var("n")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), rule: App(Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Force(Var("nat_sub")), clas: Ok(Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty))), rule: Force(Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Synth, term: Var("nat_sub"), clas: Ok(Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), rule: Var("nat_sub"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Prim(Nat)), term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), dir: Check(Prim(Nat)), term: Nat(1), clas: Ok(Prim(Nat)), rule: Nat(1), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Let("seq_ref", App(Force(Var("seq_gen")), Var("pred")), Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref")))))))))))))), clas: Err(ParamNoSynth(1)), rule: Let("seq_ref", Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: App(Force(Var("seq_gen")), Var("pred")), clas: Err(UnexpectedCEffect(ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), rule: App(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Force(Var("seq_gen")), clas: Ok(ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty)))))), rule: Force(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Var("seq_gen"), clas: Ok(Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), rule: Var("seq_gen"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Var("pred"), clas: Ok(Prim(Nat)), rule: Var("pred"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: true } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Let("leaf_ref", Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))))))))))), clas: Err(ParamNoSynth(1)), rule: Let("leaf_ref", Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Ref(Var("nm"), Roll(Inj2(Inj1(Pair(Var("nm"), Var("n")))))), clas: Err(Inside(VarNotInScope("nm"))), rule: Ref(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Var("nm"), clas: Err(VarNotInScope("nm")), rule: Var("nm"), vis: DerVis { tmfam: "Val", local_err: true } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Roll(Inj2(Inj1(Pair(Var("nm"), Var("n"))))), clas: Err(NoSynthRule), rule: Roll(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Inj2(Inj1(Pair(Var("nm"), Var("n")))), clas: Err(NoSynthRule), rule: Inj2(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Inj1(Pair(Var("nm"), Var("n"))), clas: Err(NoSynthRule), rule: Inj1(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Pair(Var("nm"), Var("n")), clas: Err(ParamNoSynth(0)), rule: Pair(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Var("nm"), clas: Err(VarNotInScope("nm")), rule: Var("nm"), vis: DerVis { tmfam: "Val", local_err: true } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: true } }), vis: DerVis { tmfam: "Val", local_err: true } }), vis: DerVis { tmfam: "Val", local_err: true } }), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Let("nmb", PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref")))))))))))), clas: Err(ParamNoSynth(1)), rule: Let("nmb", Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: PrimApp(NameBin(Var("nm"), Name(Sym("bin")))), clas: Err(ParamNoSynth(0)), rule: PrimApp(NameBin(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Var("nm"), clas: Err(VarNotInScope("nm")), rule: Var("nm"), vis: DerVis { tmfam: "Val", local_err: true } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Name(Sym("bin")), clas: Ok(Nm(Sing(Name(Sym("bin"))))), rule: Name(Sym("bin")), vis: DerVis { tmfam: "Val", local_err: false } })), vis: DerVis { tmfam: "Exp", local_err: false } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Ref(Var("nmb"), Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))))))))), clas: Err(Inside(VarNotInScope("nmb"))), rule: Ref(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Var("nmb"), clas: Err(VarNotInScope("nmb")), rule: Var("nmb"), vis: DerVis { tmfam: "Val", local_err: true } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Roll(Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref")))))))))), clas: Err(NoSynthRule), rule: Roll(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Inj2(Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))))))), clas: Err(NoSynthRule), rule: Inj2(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Inj2(Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref")))))))), clas: Err(NoSynthRule), rule: Inj2(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Pack(Unknown, Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))))), clas: Err(NoSynthRule), rule: Pack(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Unknown, clas: Err(UnknownIdxTm), rule: Unknown, vis: DerVis { tmfam: "IdxTm", local_err: true } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Pack(Unknown, Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref")))))), clas: Err(NoSynthRule), rule: Pack(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Unknown, clas: Err(UnknownIdxTm), rule: Unknown, vis: DerVis { tmfam: "IdxTm", local_err: true } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Pack(Unknown, Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))))), clas: Err(NoSynthRule), rule: Pack(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Unknown, clas: Err(UnknownIdxTm), rule: Unknown, vis: DerVis { tmfam: "IdxTm", local_err: true } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Pair(Var("nmb"), Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref")))), clas: Err(ParamNoSynth(0)), rule: Pair(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Var("nmb"), clas: Err(VarNotInScope("nmb")), rule: Var("nmb"), vis: DerVis { tmfam: "Val", local_err: true } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Pair(Var("n"), Pair(Var("leaf_ref"), Var("seq_ref"))), clas: Err(ParamNoSynth(1)), rule: Pair(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Var("n"), clas: Ok(Prim(Nat)), rule: Var("n"), vis: DerVis { tmfam: "Val", local_err: false } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Pair(Var("leaf_ref"), Var("seq_ref")), clas: Err(ParamNoSynth(0)), rule: Pair(Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Var("leaf_ref"), clas: Err(VarNotInScope("leaf_ref")), rule: Var("leaf_ref"), vis: DerVis { tmfam: "Val", local_err: true } }, Der { ctx: Var(Var(Var(IVar(IVar(IVar(Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), "Y1", NmSet), "X1", NmSet), "Y2", NmSet), "n", Prim(Nat)), "sugar_if_scrutinee", Prim(Bool)), "pred", Prim(Nat)), dir: Synth, term: Var("seq_ref"), clas: Err(VarNotInScope("seq_ref")), rule: Var("seq_ref"), vis: DerVis { tmfam: "Val", local_err: true } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: true } }), vis: DerVis { tmfam: "Val", local_err: true } }), vis: DerVis { tmfam: "Val", local_err: true } }), vis: DerVis { tmfam: "Val", local_err: true } }), vis: DerVis { tmfam: "Val", local_err: true } }), vis: DerVis { tmfam: "Val", local_err: true } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: true } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Module", local_err: false } } })], ctx_out: Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))) } }, Der { ctx: Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), dir: Synth, term: Ret(Nat(0)), clas: Ok(Cons(Lift(Prim(Nat)), WR(Empty, Empty))), rule: Ret(Der { ctx: Var(Def(Def(Def(Var(Var(Var(Def(Var(Var(Var(Empty, "nat_is_zero", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_is_odd", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty)))), "nat_sub", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Arrow(Prim(Nat), Cons(Lift(Prim(Nat)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))), "OpNat", Type(Sum(Unit, Prim(Nat)))), "nat_succ_even", Thk(Empty, Cons(Arrow(Prim(Nat), Cons(Lift(IdentDef("OpNat", Sum(Unit, Prim(Nat)))), WR(Empty, Empty))), WR(Empty, Empty)))), "name_of_nat", Thk(Empty, ForallIdx("X", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Nm(Var("X"))), WR(Empty, Empty))), WR(Empty, Empty))))), "name_eq", Thk(Empty, ForallIdx("X", NmSet, Tt, ForallIdx("Y", NmSet, Tt, Cons(Arrow(Nm(Var("X")), Cons(Arrow(Nm(Var("Y")), Cons(Lift(Prim(Bool)), WR(Empty, Empty))), WR(Empty, Empty))), WR(Empty, Empty)))))), "Lev", Type(Prim(Nat))), "Seq", Type(Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y")))))))))))))))), "RefSeq", Type(IdxFn("X", NmSet, IdxFn("Y", NmSet, Ref(Var("Y"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X")), Var("Y"))))))), "seq_gen", Thk(Empty, ForallIdx("Y1", NmSet, Tt, ForallIdx("X1", NmSet, Tt, ForallIdx("Y2", NmSet, Tt, Cons(Arrow(Prim(Nat), Cons(Lift(Ref(Var("Y1"), IdxApp(IdxApp(IdentDef("Seq", Rec("seq", IdxFn("X", NmSet, IdxFn("Y", NmSet, Sum(Unit, TypeApp(Prod(Nm(Var("X")), Prim(Nat)), Exists("X1", NmSet, Tt, Exists("X2", NmSet, Tt, Exists("X3", NmSet, Equiv(Apart(Apart(Var("X1"), Var("X2")), Var("X3")), Var("X"), NmSet), Prod(Nm(Var("X1")), Prod(IdentDef("Lev", Prim(Nat)), Prod(Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X2")), Var("Y"))), Ref(Var("Y"), IdxApp(IdxApp(Var("seq"), Var("X3")), Var("Y"))))))))))))))), Var("X1")), Var("Y2")))), WR(Empty, Empty))), WR(Empty, Empty))))))), dir: Synth, term: Nat(0), clas: Ok(Prim(Nat)), rule: Nat(0), vis: DerVis { tmfam: "Val", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }), vis: DerVis { tmfam: "Exp", local_err: false } }, traces: [] }